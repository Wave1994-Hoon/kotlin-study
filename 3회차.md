# 생성자
## 생성자 종류와 동작 방식
![image](https://user-images.githubusercontent.com/60383031/200048353-b75c5104-1ed2-442c-a79d-a24cb67b32e7.png)

코틀린의 생성자는 주생성자, 부생성자로 나뉠 수 있다.

부생성자는 반드시 주생성자를 호출하게 된다.

<br>

![image](https://user-images.githubusercontent.com/60383031/200049313-00e24655-501b-482e-a091-11b7c0c2c934.png)


부생성자는 주생성자를 호출하고 주생성자는 init 을 호출한다.

호출순서를 정리하면 `부생성자 호출 -> 주생성자 호출 -> init 블록` 실행 순으로 이어진다.

추가로 코틀린의 init 블록과 자바의 static 블록은 차이가 있다.

코틀린의 init 은 주생성자에 병합되는 코드이다. 

<br>

![image](https://user-images.githubusercontent.com/60383031/200049940-c05f8282-f3ce-4711-9ddf-dc7ce824cd2f.png)

init 블록을 여러개 사용한다면 위 예제처럼 순차적으로 실행이 된다. 

따라서 보통 코틀린에서는 init 블록을 가장 마지막에 넣는다. 왜냐하면 모든 정의가 끝난 후에 사용하기 위해서이다.

코드 리팩토링 과정 중 init 블록 순서가 뒤바뀐다면 코드 결과가 바뀔 수 있다.

<br>

![image](https://user-images.githubusercontent.com/60383031/200050401-67eb3740-9eb3-4eb2-8ec8-18a26916ac78.png)

주 생성자 속성할당이 먼저 일어나고 그 다음 순차적으로 실행이 된다.

<br>

## 생성자에 property 를 선언
자바 코드를 보면 대부분의 클래스에서 생성자의 역할은 단순히 프로퍼티에 값을 할당하는 역할만 하게된다.

코틀린에서는 코드를 직접 작성할 필요 없이 생성자에 property 를 선언할 수 있게 지원한다,

```kotlin
class TestUser(
    private val user: String, 
    private val pw: String
) { 

    constructor(user: String): this(user + "+", "") 
    
    init {
        println("test!")
        this.user = user + "-"
    }
}
```

주생성자에 프로퍼티를 선언한 경우, 최상위 init 블록보다도 높은 순서로 매칭된다.

```kotlin
public final class TestUser {
   private final String user;
   private final String pw;

   public TestUser(@NotNull String user, @NotNull String pw) {
      Intrinsics.checkNotNullParameter(user, "user");
      Intrinsics.checkNotNullParameter(pw, "pw");
      super();
      this.user = user; // 순서가 init 보다도 높음
      this.pw = pw;
      String var3 = "test!";
      System.out.println(var3); // init 블록
   }

   public TestUser(@NotNull String user) {
      Intrinsics.checkNotNullParameter(user, "user");
      this(user + "+", "");
   }
}
```
<br>

## 베스트 예제
### 생성자가 1개인 경우 :: 주 생성자 + 속성 할당 + init (요걸 Hika 님은 주생성자 전략이라고 하심)

```kotlin
class TestUser(
    private val user: String, 
    private val pw: String
) {         
    init {
        this.pw = pw + "-"
    }
}
```

주생성자 전략에서는 왠만한 속성을 받은 다음, 가공이 필요한경우 init 블록에서 하도록 작성하는 방법이다.

<br>

### 생성자가 여러개인 경우 :: 기본 값으로 해결 가능한 경우 (Kotlin Style)

```kotlin
class TestUser(
    private val user: String, 
    private val pw: String = ""
) {         
    init {
        this.pw = pw + "-"
    }
}
```

위 예시처럼 작성을 하게 되면 user,pw 를 받은 경우, user 만 받은 경우 모두 대응이 가능하다.

즉 생성자 하나로 두개의 생성자 역할을 하는 효과를 볼 수 있다.

<br>

### 생성자가 여러개인 경우 :: 인자의 타입이 달라 기본 값으로 해결할 수 없는 경우 부 생성자만 사용 (Java Style) 

```kotlin
class TestUser(
    private val user: String, 
    private val pw: String = ""
) {         
    constructor(user; String, pw: String) {
      this.user = user
      this.pw = pw
    }
    
    constructor(user; String, pw: Int) {
      this.user = user
      this.pw = pw
    }
}
```

이런 케이스에서 부생성자만을 사용하는 것보다는 팩토리 메서드를 사용하는 것이 좋다.

<br>

# OOP
## 객체지향 언어
### 객체지향을 처음부터 지원하는 언어는 아래와 같이 두 가지 특징을 만족한다.
#### 대체가능성
- 하위형은 상위형으로 대체할 수 있음
- Parent 에 Child 를 대입가능

#### 내적동질성
- 어떤 형으로 객체를 참조해도 원래 형으로 동작한다.

```kotlin
open class Parent {
    protected open fun print() {
        println("parent")
    }

    fun message() {
        println()
    }
}

class Child : Parent() {
    override fun print() { 
        println("child")
    }
}

fun main() {
    val actor: Parent = Child() // 대체가능성, 하위형은 상위형에 들어갈 수 있다.
    actor.message()
}
```

위 예시를 보면, actor는 Parent 타입임에도 불구하고, Chile 로 생성이 되었기에 message 를 호출하였을 때 "child" 가 출려깅 된다.

정리하자면, 상위 타입을 사용하더라라도 생성할 때 사용한 객체의 성질을 계속 가지고 있는 것이 내적 동질성이라고 볼 수 있다.

<br>

유명한 아키텍트들은 클래스가 최대한 오픈되어 있어야한다 왜냐하면 미래에 객체 확장을 막는다. <- 고수의 영역 ??

코틀린이 적용한 사상은 함부로 확장을 열어두면 기본적으로 막고 필요할때 열어야한다는 것이다.

<br>

### 정리
클래스가 있느냐, 프로토타입이냐는 중요하지 않다. 

어떤 시스템을 사용하든 위 두 가지를 만족해야 객체지향 언어라고 말할 수 있다.

마지막으로 언어의 기법과 프로그래밍 기법은 전혀다르다. 아래에서 그 내용을 다룬다.

<br>

## 객체지향 프로그래밍
### 객체지향 프로그램은 아래 두 가지를 만족해야한다.
#### (1) 어떤 문제를 해결할 때 객체 간의 협력으로 해결한다.
#### (2) 객체는 협력을 위해 메세지를 주고 받는다. <- 메소드를 호출함으로써 
- 메세지를 보낼 수 없는 객체는 객체가 아니다.
- 객체는 오직 메소드로만 정체성을 알 수 있다.

### 정리
변화율에 따라 코드를 역할로 나누고, 역할에 맞는 객체를 만든 뒤, 코드를 `최대한 다른 객체에게 떠민다.`

역할이 아닌 구체적인 대상으로 
역할이 아닌 구체적인 대상으로 나누기 
역할이 아닌 구체적인 대상으로 나누기 ㄷ


#### 변화율
내가 코드를 바꿔야하는 이유, 코드를 바꾸는 이유는 다양하다. 정책이나 사람의 변심 등등

따라서 코드를 바뀌는 이유를 하나로 맞추는 것이 필요하다. 쪼개고 쪼갠다. <- SRP








