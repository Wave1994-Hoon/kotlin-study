# 생성자
## 생성자 종류와 동작 방식
![image](https://user-images.githubusercontent.com/60383031/200048353-b75c5104-1ed2-442c-a79d-a24cb67b32e7.png)

코틀린의 생성자는 주생성자, 부생성자로 나뉠 수 있다.

부생성자는 반드시 주생성자를 호출하게 된다.

<br>

![image](https://user-images.githubusercontent.com/60383031/200049313-00e24655-501b-482e-a091-11b7c0c2c934.png)


부생성자는 주생성자를 호출하고 주생성자는 init 을 호출한다.

호출순서를 정리하면 `부생성자 호출 -> 주생성자 호출 -> init 블록` 실행 순으로 이어진다.

추가로 코틀린의 init 블록과 자바의 static 블록은 차이가 있다.

코틀린의 init 은 주생성자에 병합되는 코드이다. 

<br>

![image](https://user-images.githubusercontent.com/60383031/200049940-c05f8282-f3ce-4711-9ddf-dc7ce824cd2f.png)

init 블록을 여러개 사용한다면 위 예제처럼 순차적으로 실행이 된다. 

따라서 보통 코틀린에서는 init 블록을 가장 마지막에 넣는다. 왜냐하면 모든 정의가 끝난 후에 사용하기 위해서이다.

코드 리팩토링 과정 중 init 블록 순서가 뒤바뀐다면 코드 결과가 바뀔 수 있다.

<br>

![image](https://user-images.githubusercontent.com/60383031/200050401-67eb3740-9eb3-4eb2-8ec8-18a26916ac78.png)

주 생성자 속성할당이 먼저 일어나고 그 다음 순차적으로 실행이 된다.

<br>

## 생성자에 property 를 선언
자바 코드를 보면 대부분의 클래스에서 생성자의 역할은 단순히 프로퍼티에 값을 할당하는 역할만 하게된다.

코틀린에서는 코드를 직접 작성할 필요 없이 생성자에 property 를 선언할 수 있게 지원한다,

```kotlin
class TestUser(
    private val user: String, 
    private val pw: String
) { 

    constructor(user: String): this(user + "+", "") 
    
    init {
        println("test!")
        this.user = user + "-"
    }
}
```

주생성자에 프로퍼티를 선언한 경우, 최상위 init 블록보다도 높은 순서로 매칭된다.

```kotlin
public final class TestUser {
   private final String user;
   private final String pw;

   public TestUser(@NotNull String user, @NotNull String pw) {
      Intrinsics.checkNotNullParameter(user, "user");
      Intrinsics.checkNotNullParameter(pw, "pw");
      super();
      this.user = user; // 순서가 init 보다도 높음
      this.pw = pw;
      String var3 = "test!";
      System.out.println(var3); // init 블록
   }

   public TestUser(@NotNull String user) {
      Intrinsics.checkNotNullParameter(user, "user");
      this(user + "+", "");
   }
}
```
<br>

## 베스트 예제
### 생성자가 1개인 경우 :: 주 생성자 + 속성 할당 + init (요걸 Hika 님은 주생성자 전략이라고 하심)

```kotlin
class TestUser(
    private val user: String, 
    private val pw: String
) {         
    init {
        this.pw = pw + "-"
    }
}
```

주생성자 전략에서는 왠만한 속성을 받은 다음, 가공이 필요한경우 init 블록에서 하도록 작성하는 방법이다.

<br>

### 생성자가 여러개인 경우 :: 기본 값으로 해결 가능한 경우 (Kotlin Style)

```kotlin
class TestUser(
    private val user: String, 
    private val pw: String = ""
) {         
    init {
        this.pw = pw + "-"
    }
}
```

위 예시처럼 작성을 하게 되면 user,pw 를 받은 경우, user 만 받은 경우 모두 대응이 가능하다.

즉 생성자 하나로 두개의 생성자 역할을 하는 효과를 볼 수 있다.

<br>

### 생성자가 여러개인 경우 :: 인자의 타입이 달라 기본 값으로 해결할 수 없는 경우 부 생성자만 사용 (Java Style) 

```kotlin
class TestUser(
    private val user: String, 
    private val pw: String = ""
) {         
    constructor(user; String, pw: String) {
      this.user = user
      this.pw = pw
    }
    
    constructor(user; String, pw: Int) {
      this.user = user
      this.pw = pw
    }
}
```

이런 케이스에서 부생성자만을 사용하는 것보다는 팩토리 메서드를 사용하는 것이 좋다.
